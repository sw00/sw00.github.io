<!DOCTYPE html>
<html lang="en">

<head>
  <!-- ## for client-side less
  <link rel="stylesheet/less" type="text/css" href="http://sett.sh/theme/css/style.less">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js" type="text/javascript"></script>
  -->
  <link rel="stylesheet" type="text/css" href="http://sett.sh/theme/css/style.css">

  <link rel="stylesheet" type="text/css" href="http://sett.sh/theme/css/pygments.css">
  <link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=PT+Sans|PT+Serif|PT+Mono">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="Sett Wai">
  <meta name="description" content="Posts and writings by Sett Wai">


<meta name="keywords" content="docker, devops, tools">

  <title>
Docker for Windows Users Part I  </title>

</head>

<body>
  <aside>
    <div id="user_meta">
      <a href="http://sett.sh">
        <img src="http://sett.sh/theme/images/logo.png" alt="logo">
      </a>
      <h2><a href="http://sett.sh">Sett Wai</a></h2>
      <p>witty blog tagline here.</p>
      <ul>
        <li><a href="http://twitter.com/settface" target="_blank">Twitter</a></li>
        <li><a href="http://github.com/sw00" target="_blank">Github</a></li>
        <li><a href="http://keybase.io/sw00" target="_blank">Keybase</a></li>
      </ul>
    </div>
  </aside>

  <main>
    <header>
<p>Posted on Tue 21 April 2015</p>
    </header>

<article>
  <div class="article_title">
    <h3><a href="http://sett.sh/docker-for-windows-users-1.html">Docker for Windows Users Part I</a></h3>
  </div>
  <div class="article_text">
    <h3>Foreword</h3>
<p>I won't actually be teaching you how to use Docker in this first post, - this one is just to explain where it all fits in. I'm also using this opportunity to explain Linux and its importance/relevance. If you want a TL;DR introduction read this <a href="http://stackoverflow.com/questions/16047306/how-is-docker-io-different-from-a-normal-virtual-machine">StackOverflow question</a>.</p>
<p>As with many people my age (27), I primarily started working and playing on computers when graphical user interfaces were already the norm and Windows 95 had just hit the peak of popularity. Unless your parents were engineers of some sort, personal computers were generally seen as just a new home appliance. If you had a computer in the 90s, it most likely was a Packard Bell that came with Windows 95 and Intel Pentium processor of some sort.</p>
<p><img alt="Packard Bell Pentium 133" src="http://i.imgur.com/7hVG709.jpg" /><br/>
<small>Low-res nostalgia bomb!</small></p>
<p>It's in this context that a lot of us grew up. However, this puts us at a disadvantage. Just as today's "apps", tablets and smart phones can be seen as relegating the general purpose computer to "Facebook" machines, ours was the first wave of this trend. The capacitive touch screen is just the evolution of the computer mouse. This is a great thing, but if you're a technologist, it's important to understand that the Windows ecosystem is only one alternate timeline in the history of computing.</p>
<p>Below, I'll go through a brief history of computing that's important to understanding why you'd want to be familiar with *nix. Especially if you're from the Windows 95 generation, like me. Bear with me as I dig through the alternate history, I'm trying to give you the same <em>ah-ha!</em> moments I got when I first discovered this stuff.</p>
<h3>In the beginning</h3>
<p>In the beginning there was UNIX. Before affordable multi-purpose, personal computers, organisations often kept a single mainframe computer that users could connect to via <a href="https://en.wikipedia.org/wiki/Computer_terminal#Dumb_terminals">"dumb" terminals</a>. This was based on the idea of <a href="https://en.wikipedia.org/wiki/Time-sharing">time-sharing</a> which was a way to give access to computing to many different people at the same time<sup id="fnref:internet"><a class="footnote-ref" href="#fn:internet" rel="footnote">1</a></sup>.</p>
<p><img alt="Tron Classic" src="http://i.imgur.com/lYUYMUG.jpg" />
<br/><small>A lot the original computing ideas are realised in <a href="http://www.imdb.com/title/tt0084827/">Tron (1982)</a>, albeit with artistic liberties taken.</small></p>
<p>UNIX as an underlying operating system provided small programs that the user could execute in order to specific tasks. These were tied together by a unified file system for communicating and a shell scripting language for doing more complex work. All of this work was mediated by a master control program, the <a href="https://en.wikipedia.org/wiki/Kernel_(operating_system)">kernel</a>.</p>
<p>Eventually in the 80s, the IEEE got together and specified a family of standards for operating systems based on common patterns they saw in UNIX and UNIX-like OSes. They called these standards collectively, <a href="https://en.wikipedia.org/wiki/POSIX">POSIX</a>. Parallel to this, a set of common software engineering practices were embodied into something called the <a href="https://en.wikipedia.org/wiki/Unix_philosophy">Unix Philosophy</a>.</p>
<p>A lot of operating systems would come to be developed adhering to POSIX standards and and the Unix philosophy. The most famous of them being Linux<sup id="fnref:linux"><a class="footnote-ref" href="#fn:linux" rel="footnote">2</a></sup> and FreeBSD<sup id="fnref:OSX"><a class="footnote-ref" href="#fn:OSX" rel="footnote">3</a></sup>.</p>
<p><img alt="Unix timeline" src="https://upload.wikimedia.org/wikipedia/commons/c/cd/Unix_timeline.en.svg" /></p>
<h3>MS-DOS &amp; Windows</h3>
<p>In 1981 IBM launched the IBM Personal Computer with a microprocessor based on its flagship 8088 chip<sup id="fnref:8088"><a class="footnote-ref" href="#fn:8088" rel="footnote">4</a></sup>. It also came installled a with tiny, simple operating system by Microsoft, called MS-DOS. Unlike UNIX-like operating systems around at the time, MS-DOS was single-task, single-user and certainly not POSIX compliant.</p>
<p><img alt="MS-DOS box" src="http://i.imgur.com/0Z1RcIAl.jpg" /></p>
<p>Personal computers became insanely popular for some reason and Microsoft introduced Windows as an addon to MS-DOS to compete with Apple's very expensive Macintosh computer. The Macintosh featured a Graphical User Interface, the hottest new thing in technology. The rest is history: Windows dominated the personal computing space through OEM deals with hardware manufacturers and eventually every computer you could buy was either a Windows or a Mac. Meanwhile, UNIX-like OSes like Linux took firm hold of the Web Server space. The numbers are very <a href="https://en.wikipedia.org/wiki/Usage_share_of_operating_systems#Market_share_by_category">telling</a>: 91.25% of all personal computers are Windows, but only a third of servers on the web.</p>
<h3>Implications</h3>
<p>What does this mean for us developers? Well, unless you're strictly into systems development<sup id="fnref:systems development"><a class="footnote-ref" href="#fn:systems development" rel="footnote">5</a></sup> only, the chances are you'll be developing applications that need to deployed to a server. This means that 2 of 3 production environments will UNIX-like.</p>
<h3>Virtualisation</h3>
<p>Because a server rack is a specialised, expensive piece of equipment, a common technique to have a more efficient distribution of resources is to use <a href="https://en.wikipedia.org/wiki/Hardware_virtualization">virtualisation</a>. Virtualisation in the context of the data centre allows sharing the same physical resources amongst multiple instances of virtual servers. </p>
<p>Apart from efficiency, virtualisation provides other benefits such as the ability to easily automatically configure them. New virtual machines can be "spun up" and provisioned without buying additional hardware up-front. You can clone/back up entire machines and move them around. These are all features that are the backbone for Infrastructure as a Service (IaaS) which simply means you can pay a provider like <a href="http://rackspace.com/">Rackspace</a>, <a href="https://www.linode.com/">Linode</a> or <a href="https://www.digitalocean.com/">Digital Ocean</a> for a Virtual Private Server and have it almost immediately.</p>
<p><img alt="Virtualisation diagram" src="https://www.vmware.com/files/images/diagrams/vmw-virtualization-defined.jpg" />
<small>VMWare explains virtualisation.</small></p>
<p>The most common scenario for virtualisation is on a hardware level: the host machine's physical resources would be virtualised and available to the guest machine as "fake" hardware. Physical things like RAM, CPU, GPU and HDD could be virtualised. A host machine with 32GB RAM, 1TB HDD and 8 CPUs could possible provide 4 virtual machines of 8GB, 250GB and 2 vCPU. The problem however, is that these resources are fixed for the duration that the VM is running - if 1 VM is idle, it can't share its 2vCPUS and 8GB RAM with the others. Also, each VM would need to boot up and run its own OS. This is still a little inefficient.</p>
<p>With regards to software development, virtualisation allows us to easily have consistent environments amongst locally through the use of <a href="http://vagrantup.com/">vagrant</a> and virtual box.</p>
<h3>Containers</h3>
<p>Containers are just another term for <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">Operating System Level Virtualisation</a>. In contrast to whole-system or hardware virtualisation, containers do not provide abstraction for physical resources. Instead, they provide a virtual userspace<sup id="fnref:userspace"><a class="footnote-ref" href="#fn:userspace" rel="footnote">6</a></sup> and directory structure for applications to be run. These applications all run on the same operating system and kernel but are isolated from each other. One application in a container would generally not be able to see or manipulate files/memory in another container.</p>
<p>Operating System Level Virtualisation ala containers has a massive advantage over hardware virtualisation in that you can easily run hundreds of containers on a host without any problems since they share all physical resources of the host system.</p>
<p><img alt="Containers vs VMs" src="http://zdnet4.cbsistatic.com/hub/i/r/2014/10/02/c5ebe949-49e6-11e4-b6a0-d4ae52e95e57/resize/770x578/54eff63621dfffda68806c80e2a411a5/azuredockervmcontainer.png" /></p>
<p>The reason why containers are not very prominent in Windows ecosystem is because of its single-user, single-process history (I stand to be corrected on this). Also containerisation was never a core operating system feature and traditionally provided by third party, proprietary software in Windows.</p>
<p>On Linux, <a href="https://en.wikipedia.org/wiki/Chroot">chroot</a> had always provided this functionality until <a href="https://wiki.archlinux.org/index.php/Linux_Containers">Linux Containers</a>(LxCs) were created in 2008. LxCs leveraged a kernel feature called <strong>cgroups</strong> to achieve a higher level of isolation adn security than what the crude chroot provided<sup id="fnref:cgroups"><a class="footnote-ref" href="#fn:cgroups" rel="footnote">7</a></sup>.</p>
<p>If the previous paragraph is kind of hard to take in, you're not alone. Containerisation in Linux is a highly technical topic and it seems to require a lot of arcane knowledge of the Linux operating systems that most developers wouldn't know of. Let alone devs who are used to Windows. This was always the case until <strong>Docker</strong> exploded on to the scene.</p>
<h3>Docker</h3>
<p>Docker was started by <a href="https://twitter.com/solomonstre">Solomon Hykes</a> in 2013 while he was at <a href="https://www.dotcloud.com/">dotCloud</a>, a Platform as a Service Provider<sup id="fnref:PaaS"><a class="footnote-ref" href="#fn:PaaS" rel="footnote">8</a></sup>. It was initially just a convenient wrapper around LxCs that stretched the metaphor of "shipping containers" for apps. The entire idea was that a docker container should run and look exactly the same on any host while being incredibly easy to automate and manage.</p>
<p>One distinctive feature docker has is that it uses the AUFS filesystem which is a layered file system. This simply means that AUFS can take a base image of filesystem and apply changes to it and each change will have it's own unique layer. In practice this is effectively source control built into the file system, with additional features of being able to mount other filesystems into paths in it.</p>
<p>Another benefit is that it allows you to run applications for any Linux distribution on the same host. Since it effectively allows you to define the userspace/userland filesystem, you can deploy an app or service in a CentOS container and it will run just fine on an Ubuntu host for example.</p>
<p>More recently, Microsoft has actually developed a docker container for <a href="https://registry.hub.docker.com/u/microsoft/aspnet/">ASP.NET</a> so you can now deploy your .NET applications on a Linux host, or <a href="http://weblogs.asp.net/scottgu/docker-and-microsoft-integrating-docker-with-windows-server-and-microsoft-azure">vice-versa</a>.</p>
<h3>What's in it for Devs?</h3>
<p>Just like Vagrant changed the way we provision and develop applications, Docker is the next step to solving the problem of "well, it works on my machine". Using Docker, you can now have an multi-service environment that is almost exactly like production running on your local machine. </p>
<p>With <a href="http://www.thoughtworks.com/insights/blog/microservices-nutshell">micro-services</a> gaining popularity, we're going to see a lot of software complexity pushed from away from dev effort and into the ops realm. But in order to remain effective devs, we're going to have care a lot more about how our code is deployed and lives in production. This partially what the <strong>DevOps</strong> movement is all about. Being able to deploy and run our entire application locally, make changes and trust that it will behave the same way in all stages is a massive win for developers and operations folk alike.</p>
<p>I've used docker to provide a local development environment for an app that consumed 7 individual services. By packaging each one into separate containers and then bundling them into a single vagrant box that can be fired up through a <a href="http://www.thoughtworks.com/insights/blog/praise-go-script-part-i">go script</a>. Sadly, we never got around to using it production but it greatly aided the production support and feature development.</p>
<p>It turns out Docker is also an extremely useful tool when dealing with critical database migrations. I've used it to create a snapshot of a production database and test migrations locally. Fortunately, it was small enough. Because of its underling AUFS filesystem, rolling back meant I simply could kill the container and firing it up again would revert it to its initial state.</p>
<h3>End</h3>
<p>I hope that this post has been helpful and gives you an idea of where docker fits in and how it came about. In the next post I'll explain how to get started with Docker and get our hands dirty. Cheers.</p>
<div class="footnote">
<hr />
<ol>
<li id="fn:internet">
<p>these principles would lay the foundation of computer interaction that we now call The Internet.&#160;<a class="footnote-backref" href="#fnref:internet" rev="footnote" title="Jump back to footnote 1 in the text">&#8617;</a></p>
</li>
<li id="fn:linux">
<p>Linux needs no introduction but it was an attempt at making an operating system that was free, unlike UNIX which only massive organisations could afford.&#160;<a class="footnote-backref" href="#fnref:linux" rev="footnote" title="Jump back to footnote 2 in the text">&#8617;</a></p>
</li>
<li id="fn:OSX">
<p>OSX is actually based off of BSD!&#160;<a class="footnote-backref" href="#fnref:OSX" rev="footnote" title="Jump back to footnote 3 in the text">&#8617;</a></p>
</li>
<li id="fn:8088">
<p>the 8088's predecessor is the 8086, which the term x86 architecture comes from.&#160;<a class="footnote-backref" href="#fnref:8088" rev="footnote" title="Jump back to footnote 4 in the text">&#8617;</a></p>
</li>
<li id="fn:systems development">
<p>You know, like C, C++, Golang and Rust where knowing about memory management is more important than REST/SOAP calls and HTTP.&#160;<a class="footnote-backref" href="#fnref:systems development" rev="footnote" title="Jump back to footnote 5 in the text">&#8617;</a></p>
</li>
<li id="fn:userspace">
<p>also known as userland, it's the context in which non-kernel programs and drivers are run. I'm unaware if Windows has the equivalent architecture. <a href="https://en.wikipedia.org/wiki/Operating-system-level_virtualization">Read more</a>&#160;<a class="footnote-backref" href="#fnref:userspace" rev="footnote" title="Jump back to footnote 6 in the text">&#8617;</a></p>
</li>
<li id="fn:cgroups">
<p>I won't go into more technical detail here, mostly because I don't know much about cgroups other than you can use it to limit memory and CPU resources to users and groups. See <a href="https://wiki.archlinux.org/index.php/Cgroups">https://wiki.archlinux.org/index.php/Cgroups</a> for more info.&#160;<a class="footnote-backref" href="#fnref:cgroups" rev="footnote" title="Jump back to footnote 7 in the text">&#8617;</a></p>
</li>
<li id="fn:PaaS">
<p>Remember IaaS? PaaS is the same thing but instead of spinning up VMs with specified RAM, vCPUs and HDD you work with spinning up services like Apache, MySQL, MongoDB, Logstache with ports, credentials and loadbalancing directly.&#160;<a class="footnote-backref" href="#fnref:PaaS" rev="footnote" title="Jump back to footnote 8 in the text">&#8617;</a></p>
</li>
</ol>
</div>
  </div>
  <div class="article_meta">
    <p>Category: <a href="http://sett.sh/category/code.html">code</a></p>
    <p>Tags:
      <a href="http://sett.sh/tag/docker.html">docker</a>,      <a href="http://sett.sh/tag/devops.html">devops</a>,      <a href="http://sett.sh/tag/tools.html">tools</a>    </p>
    <p>Comments: <a href="#" onclick="javascript:toggleComments();return false;">toggle</a></p>
  </div>

    <div id="article_comments" style="display:block">
        <div id="disqus_thread"></div>
        <script type="text/javascript">
           var disqus_identifier = "docker-for-windows-users-1.html";
           (function() {
           var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
           dsq.src = 'http://sett-sh.disqus.com/embed.js';
           (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
          })();
        </script>
    </div>

</article>

    <footer>
<p><a href="http://sett.sh/" class="button_accent">&larr; Back to Index</a></p>
<script language="javascript">
    function toggleComments() {
        var commentDiv = document.getElementById("article_comments");
        (commentDiv.style.display == "none") ? commentDiv.style.display = "block" : commentDiv.style.display = "none";
        return false;
    }
</script>
    </footer>

    <div id="ending_message">
      <p>&copy; Sett Wai. Built using <a href="http://getpelican.com" target="_blank">Pelican</a>. Theme by Giulio Fidente on <a href="https://github.com/giulivo/pelican-svbhack" target="_blank">github</a>. .</p>
    </div>
  </main>
</body>
</html>